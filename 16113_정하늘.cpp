#include<stdio.h>
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>


using namespace std;

vector<string> v = {
	"####.##.##.####",//0
	"#####",//1
	"###..#####..###",//2
	"###..####..####",//3
	"#.##.####..#..#",//4
	"####..###..####",//5
	"####..####.####",//6
	"###..#..#..#..#",//7
	"####.#####.####",//8
	"####.####..####",//9
	"....."//empty
};

int col_pointer = 0;
int n;
string s;
int col;


int comp_empty_one() {
	string r;
	for (int i = col_pointer; i < n; i += col) {
		r += s[i];
	}
	if (v[10] == r) return 0;
	if (v[1] == r) return 1;
	return 2;
}

int comp_num() {
	string r;
	for (int i = col_pointer; i < n; i += col) {
		r += s[i];
		r += s[i + 1];
		r += s[i + 2];
	}
	for (int i = 0; i <= 9; i++) {
		if (i == 1) continue;
		if (v[i] == r) return i;
	}
	return 20;
}


int main() {
	cin.tie(NULL);
	std::ios::sync_with_stdio(false);

	string ans = "";
	cin >> n >> s;

	col = n / 5;

	while (col_pointer < col) {
		int cmp1 = comp_empty_one();
		if (cmp1 == 0) {
			col_pointer++;
		}
		else {
			if (col_pointer + 2 < col) {
				int cmp2 = comp_num();
				if (cmp2 == 20) {
					ans += '1';
					col_pointer++;
				}
				else {
					ans += cmp2 + '0';
					col_pointer += 3;
				}
			}
			else {
				ans += '1';
				col_pointer++;
			}
		}
	}
	cout << ans << '\n';
}



/*
16113. 시그널
https://www.acmicpc.net/problem/16113

문제
zxcvber는 외계인을 연구하는 과학자다. 그는 지난 10년간 우주에서 오는 시그널를 연구했지만, 아무런 성과가 없었다. 그러던 어느 날, 갑자기 우주에서 이상한 시그널이 오기 시작했다. zxcvber는 매우 기뻐하며 시그널을 받아서 분석해보았다. 시그널은 0과 1로 이루어져 있는데, 여기서는 편의상 0을 ".", 1을 "#"으로 표시한다. 시그널은 다음과 같았다.

###.....###.#..####.#.......#.#....####.....###.#....##.#.......#.#....####.....###.#....#

다른 여러 시그널들을 분석해본 결과, zxcvber는 시그널의 길이가 항상 5의 배수라는 것을 알게 되었다. 시그널을 다섯 개로 쪼개면 뭔가 규칙이 보이지 않을까 생각한 zxcvber는 시그널을 같은 길이의 5개의 시그널로 쪼갰다. 그러자 놀라운 일이 벌어졌다. 아래는 시그널을 쪼갠 뒤 "#"을 검은색, "."을 흰색으로 표시한 그림이다.



시그널은 디지털 숫자를 나타내고 있었다! 1-3열에 8, 9-11열에 3, 13열에 1, 그리고 16-18열에 7이 나타난 것이다. 이 숫자들이 특별한 의미를 갖고 있을 것이라 생각한 zxcvber는 다른 시그널들도 해독을 하기 시작했다. 하지만 시그널들의 길이가 너무 길어서, 일일히 손으로 확인하기에는 한계가 있었다. 다만, 짧은 시그널들을 분석하면서 zxcvber는 시그널의 규칙들을 파악할 수 있었다.

1. 시그널은 "."과 "#"으로 이루어져 있다.
2. 시그널을 해독한 결과에는 반드시 숫자가 1개 이상 있다.
3. 시그널에 등장하는 모든 "#"은 올바른 숫자 패턴에 포함되어 있다.
4. 숫자와 숫자 사이에는 1열 이상의 공백이 있다. 여기서 공백은, 열의 성분이 모두 "."인 열을 의미한다.
5. 0부터 9는 아래와 같이 나타난다. 역시 "#"을 검은색, "."을 흰색으로 표시했다.



주의할 점은, 1은 다른 숫자들과는 다르게 1열을 차지한다는 것이다. zxcvber를 도와 시그널을 해독해보자!

입력
입력의 첫 줄에는 시그널의 길이 N(5 ≤ N ≤ 100,000, N은 5의 배수)이 주어진다.

다음 줄에 시그널이 주어진다. zxcvber가 찾아낸 규칙을 따르는 시그널만이 입력으로 주어진다.

출력
첫 번째 줄에 시그널을 해독하여 나오는 숫자들을 순서대로 출력한다.


각 열 별로 string 재구성, empty인지 먼저 체크.
col_pointer를 둬서 어느 열을 가리키는지 체크
empty가 아닌 경우
1. 남은 열이 3개 이상인 경우 -> 숫자 비교 -> comp_num 함수 호출. 1을 제외하고 0~9 중 일치하는 수를 찾음. 없는 경우 해당 숫자는 1, 있는 경우는 해당 수.
2. 남은 열이 3개 미만인 경우 -> 반드시 1

*/
